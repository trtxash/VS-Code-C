#### 1. **类内定义（默认 `inline`）的适用场景**

- **简单函数**：逻辑简单、代码量少（如 `getter/setter`），内联可减少调用开销。
- **模板函数**：模板的实现必须对编译器可见，通常直接写在类内或头文件中。
- **性能敏感代码**：高频调用的短函数（如数学运算）内联可优化性能。
- **代码紧凑性**：小型工具类或仅局部使用的类，集中代码更易读。

#### 2. **类外定义（需显式分离）的优势**

- **接口分离**：声明（`.h`）与实现（`.cpp`）分离，降低耦合性。
- **编译依赖**：修改实现时只需重新编译 `.cpp`，加速大型项目构建。
- **可维护性**：复杂逻辑独立成源文件，便于调试和版本管理。
- **二进制体积**：避免过度内联导致的可执行文件膨胀。

#### 3. **代码示例对比**

```cpp
// 类内定义（隐式 inline）
class Vector {
public:
    double x, y;
    double length() const { 
        return std::sqrt(x*x + y*y); 
    }
};
```

```cpp
// 类外定义（声明与实现分离）
// Vector.h
class Vector {
public:
    double x, y;
    double length() const; // 仅声明
};

// Vector.cpp
#include "Vector.h"
double Vector::length() const {
    return std::sqrt(x*x + y*y);
}
```

#### 4. **实际项目中的建议**

- **遵循团队规范**：优先遵守项目的代码风格指南（如 Google C++ Style）。
- **头文件管理**：若在头文件中类外定义，需标记为 `inline` 避免重复定义：

  ```cpp
  // Vector.h
  class Vector {
  public:
      double length() const;
  };

  inline double Vector::length() const { 
      return /*...*/; 
  }
  ```

- **模板类/函数**：必须在头文件中实现，无论类内或外。

#### 5. **性能测试工具辅助**

- 通过 `g++ -S` 生成汇编代码，观察内联效果。
- 使用性能分析工具（如 `perf`）验证热点函数是否适合内联。

#### 总结

- **优先类外定义**：复杂逻辑、需隐藏实现细节时。
- **优先类内定义**：短小简单、高频调用、模板场景。
- **平衡可读性与效率**：避免过度内联导致代码膨胀，同时保持关键路径性能。

最终决策应基于代码规模、维护需求和性能数据的综合分析。

---
---

在 C++ 中，类内运算符重载的参数数量取决于运算符类型：

1. **对于成员函数形式的运算符重载**：

- 单目运算符：没有显式参数（隐式使用 this 指针）
- 双目运算符：只能有 1 个显式参数（左操作数是 this 指针，右操作数是参数）

2. **对于友元/非成员函数形式的运算符重载**：

- 单目运算符：需要 1 个参数
- 双目运算符：需要 2 个参数

关键点：

- `operator*=` 是成员运算符，正确使用了 1 个参数
- `operator*` 需要处理两种顺序（float*DateTime 和 DateTime*float）
- 通过友元函数实现参数顺序自由性
- 推荐复用 `operator*=` 来实现 `operator*` 以提高代码复用性
